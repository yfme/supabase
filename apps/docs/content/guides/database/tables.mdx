---
id: 'tables'
title: '表格和数据'
description: '创建和使用 Postgres 表格。'
video: 'https://www.youtube.com/v/TKwF3IGij5c'
---

表格是存储数据的地方。

表格类似于 Excel 电子表格。它们包含列和行。
例如，这个表有 3 个"列"（`id`、`name`、`description`）和 4 个"行"数据：

{/* supa-mdx-lint-disable Rule003Spelling */}

| `id` | `name`               | `description`                                                                                                                                                 |
| ---- | -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1    | The Phantom Menace   | Two Jedi escape a hostile blockade to find allies and come across a young boy who may bring balance to the Force.                                             |
| 2    | Attack of the Clones | Ten years after the invasion of Naboo, the Galactic Republic is facing a Separatist movement.                                                                 |
| 3    | Revenge of the Sith  | As Obi-Wan pursues a new threat, Anakin acts as a double agent between the Jedi Council and Palpatine and is lured into a sinister plan to rule the galaxy.   |
| 4    | Star Wars            | Luke Skywalker joins forces with a Jedi Knight, a cocky pilot, a Wookiee and two droids to save the galaxy from the Empire's world-destroying battle station. |

{/* supa-mdx-lint-enable Rule003Spelling */}

如果您是关系型数据库的新手，电子表格是一个很好的起点，但两者之间存在一些重要差异。

## 创建表格

创建表格时，最佳做法是同时添加列。

<Image
  alt="表格和列"
  zoomable
  src={{
    dark: '/docs/img/database/managing-tables/creating-tables.png',
    light: '/docs/img/database/managing-tables/creating-tables--light.png',
  }}
/>

创建列时，必须定义每列的"数据类型"。创建表格后，您可以随时添加和删除列。

Supabase 提供了几种创建表格的选项。您可以使用仪表板或直接使用 SQL 创建它们。
我们在仪表板中提供了 SQL 编辑器，或者您可以[连接](../../guides/database/connecting-to-postgres)到您的数据库
并自己运行 SQL 查询。

<Tabs
  scrollable
  size="small"
  type="underlined"
  defaultActiveId="dashboard"
  queryGroup="database-method"
>
<TabPanel id="dashboard" label="仪表板">

<video width="99%" muted playsInline controls={true}>
  <source
    src="https://xguihxuzqibwxjnimxev.supabase.co/storage/v1/object/public/videos/docs/api/api-create-table-sm.mp4"
    type="video/mp4"
  />
</video>

1. 在仪表板中转到[表格编辑器](https://supabase.com/dashboard/project/_/editor)页面。
2. 点击**新建表格**并创建一个名为 `todos` 的表格。
3. 点击**保存**。
4. 点击**新建列**并创建一个名为 `task` 且类型为 `text` 的列。
5. 点击**保存**。

</TabPanel>
<TabPanel id="sql" label="SQL">

```sql
create table movies (
  id bigint generated by default as identity primary key,
  name text,
  description text
);
```

</TabPanel>
</Tabs>

<Admonition type="note">

命名表格时，请使用小写字母和下划线而不是空格（例如，用 `table_name`，而不是 `Table Name`）。

</Admonition>

## 列

创建列时必须定义"数据类型"。

### 数据类型

每列都是预定义的类型。Postgres 提供了许多[默认类型](https://www.postgresql.org/docs/current/datatype.html)，如果默认类型不符合您的需求，您甚至可以设计自己的类型（或使用扩展）。您可以通过 SQL 编辑器使用 Postgres 支持的任何数据类型。在表格编辑器中，我们只支持这些类型的一个子集，以使体验对于数据库经验较少的人来说更加简单。

<details>
<summary>显示/隐藏默认数据类型</summary>

| `名称`                            | `别名`        | `描述`                                           |
| --------------------------------- | ------------- | ------------------------------------------------ |
| `bigint`                          | `int8`        | 有符号的八字节整数                               |
| `bigserial`                       | `serial8`     | 自动递增的八字节整数                             |
| `bit`                             |               | 固定长度的位字符串                               |
| `bit varying`                     | `varbit`      | 可变长度的位字符串                               |
| `boolean`                         | `bool`        | 逻辑布尔值（真/假）                             |
| `box`                             |               | 平面上的矩形框                                   |
| `bytea`                           |               | 二进制数据（"字节数组"）                         |
| `character`                       | `char`        | 固定长度的字符串                                 |
| `character varying`               | `varchar`     | 可变长度的字符串                                 |
| `cidr`                            |               | IPv4 或 IPv6 网络地址                            |
| `circle`                          |               | 平面上的圆                                       |
| `date`                            |               | 日历日期（年、月、日）                           |
| `double precision`                | `float8`      | 双精度浮点数（8 字节）                           |
| `inet`                            |               | IPv4 或 IPv6 主机地址                            |
| `integer`                         | `int`, `int4` | 有符号的四字节整数                               |
| `interval [ fields ]`             |               | 时间跨度                                         |
| `json`                            |               | 文本 JSON 数据                                   |
| `jsonb`                           |               | 二进制 JSON 数据，已分解                         |
| `line`                            |               | 平面上的无限线                                   |
| `lseg`                            |               | 平面上的线段                                     |
| `macaddr`                         |               | MAC（媒体访问控制）地址                          |
| `macaddr8`                        |               | MAC（媒体访问控制）地址（EUI-64 格式）           |
| `money`                           |               | 货币金额                                         |
| `numeric`                         | `decimal`     | 可选精度的精确数值                               |
| `path`                            |               | 平面上的几何路径                                 |
| `pg_lsn`                          |               | Postgres 日志序列号                              |
| `pg_snapshot`                     |               | 用户级事务 ID 快照                               |
| `point`                           |               | 平面上的几何点                                   |
| `polygon`                         |               | 平面上的闭合几何路径                             |
| `real`                            | `float4`      | 单精度浮点数（4 字节）                           |
| `smallint`                        | `int2`        | 有符号的两字节整数                               |
| `smallserial`                     | `serial2`     | 自动递增的两字节整数                             |
| `serial`                          | `serial4`     | 自动递增的四字节整数                             |
| `text`                            |               | 可变长度的字符串                                 |
| `time [ without time zone ]`      |               | 一天中的时间（无时区）                           |
| `time with time zone`             | `timetz`      | 一天中的时间，包括时区                           |
| `timestamp [ without time zone ]` |               | 日期和时间（无时区）                             |
| `timestamp with time zone`        | `timestamptz` | 日期和时间，包括时区                             |
| `tsquery`                         |               | 文本搜索查询                                     |
| `tsvector`                        |               | 文本搜索文档                                     |
| `txid_snapshot`                   |               | 用户级事务 ID 快照（已弃用；请参阅 pg_snapshot） |
| `uuid`                            |               | 通用唯一标识符                                   |
| `xml`                             |               | XML 数据                                         |

</details>

<br />

您可以将列从一种类型"转换"为另一种类型，但是不同类型之间可能存在一些不兼容性。
例如，如果您将 `timestamp` 转换为 `date`，您将丢失之前保存的所有时间信息。

### 主键

表格可以有一个"主键"—每行数据的唯一标识符。关于主键的几个提示：

- 建议为数据库中的每个表创建主键。
- 您可以使用任何列作为主键，只要它对每行都是唯一的。
- 通常使用 `uuid` 类型或编号的 `identity` 列作为主键。

```sql
create table movies (
  id bigint generated always as identity primary key
);
```

在上面的例子中，我们：

1. 创建了一个名为 `id` 的列
1. 将数据类型分配为 `bigint`
1. 指示数据库这应该 `generated always as identity`，这意味着 Postgres 将自动为此列分配一个唯一的数字。
1. 因为它是唯一的，所以我们也可以将其用作 `primary key`。

我们也可以使用 `generated by default as identity`，这将允许我们插入自己的唯一值。

```sql
create table movies (
  id bigint generated by default as identity primary key
);
```

## 加载数据

在 Supabase 中有几种加载数据的方法。您可以直接将数据加载到数据库或使用 [API](../../guides/database/api)。
如果您正在加载大型数据集，请使用"批量加载"说明。

### 基本数据加载

<Tabs
  scrollable
  size="small"
  type="underlined"
  defaultActiveId="sql"
  queryGroup="language"
>
<TabPanel id="sql" label="SQL">

```sql
insert into movies
  (name, description)
values
  (
    'The Empire Strikes Back',
    'After the Rebels are brutally overpowered by the Empire on the ice planet Hoth, Luke Skywalker begins Jedi training with Yoda.'
  ),
  (
    'Return of the Jedi',
    'After a daring mission to rescue Han Solo from Jabba the Hutt, the Rebels dispatch to Endor to destroy the second Death Star.'
  );
```

</TabPanel>
<TabPanel id="js" label="JavaScript">

```js
const { data, error } = await supabase.from('movies').insert([
  {
    name: 'The Empire Strikes Back',
    description:
      'After the Rebels are brutally overpowered by the Empire on the ice planet Hoth, Luke Skywalker begins Jedi training with Yoda.',
  },
  {
    name: 'Return of the Jedi',
    description:
      'After a daring mission to rescue Han Solo from Jabba the Hutt, the Rebels dispatch to Endor to destroy the second Death Star.',
  },
])
```

</TabPanel>
<TabPanel id="dart" label="Dart">

```dart
await supabase
  .from('movies')
  .insert([{
    name: 'The Empire Strikes Back',
    description: 'After the Rebels are brutally overpowered by the Empire on the ice planet Hoth, Luke Skywalker begins Jedi training with Yoda.'
  }, {
    name: 'Return of the Jedi',
    description: 'After a daring mission to rescue Han Solo from Jabba the Hutt, the Rebels dispatch to Endor to destroy the second Death Star.'
  }]);
```

</TabPanel>
<TabPanel id="swift" label="Swift">

```swift
try await supabase.from("movies")
  .insert(
    [
      [
        "name": "The Empire Strikes Back",
        "description":
          "After the Rebels are brutally overpowered by the Empire on the ice planet Hoth, Luke Skywalker begins Jedi training with Yoda.",
      ],
      [
        "name": "Return of the Jedi",
        "description":
          "After a daring mission to rescue Han Solo from Jabba the Hutt, the Rebels dispatch to Endor to destroy the second Death Star.",
      ],
    ]
  )
  .execute()
```

</TabPanel>
<TabPanel id="python" label="Python">

```python
client.from_("movies").insert([
    {
        "name": "The Empire Strikes Back",
        "description": "After the Rebels are brutally overpowered by the Empire on the ice planet Hoth, Luke Skywalker begins Jedi training with Yoda."
    },
    {
        "name": "Return of the Jedi",
        "description": "After a daring mission to rescue Han Solo from Jabba the Hutt, the Rebels dispatch to Endor to destroy the second Death Star."
    }
]).execute()
```

</TabPanel>
<TabPanel id="kotlin" label="Kotlin">

```kotlin
@Serializable
data class Movie(
    val name: String,
    val description: String
)
```

```kotlin
supabase
    .from("movies")
    .insert(listOf(
        Movie("The Empire Strikes Back", "After the Rebels are brutally overpowered by the Empire on the ice planet Hoth, Luke Skywalker begins Jedi training with Yoda."),
        Movie("Return of the Jedi", "After a daring mission to rescue Han Solo from Jabba the Hutt, the Rebels dispatch to Endor to destroy the second Death Star."),
    ))
```

</TabPanel>
</Tabs>

### 批量数据加载

在插入大型数据集时，最好使用 PostgreSQL 的 [COPY](https://www.postgresql.org/docs/current/sql-copy.html) 命令。
这会将数据直接从文件加载到表中。有几种可用的文件格式可用于复制数据：文本、CSV、二进制、JSON 等。

例如，如果您想将 CSV 文件加载到电影表中：

```text ./movies.csv
"The Empire Strikes Back", "After the Rebels are brutally overpowered by the Empire on the ice planet Hoth, Luke Skywalker begins Jedi training with Yoda."
"Return of the Jedi", "After a daring mission to rescue Han Solo from Jabba the Hutt, the Rebels dispatch to Endor to destroy the second Death Star."
```

您需要直接[连接](../../guides/database/connecting-to-postgres#direct-connections)到您的数据库并使用 COPY 命令加载文件：

```bash
psql -h DATABASE_URL -p 5432 -d postgres -U postgres \
  -c "\COPY movies FROM './movies.csv';"
```

此外，可以使用 Postgres [COPY](https://www.postgresql.org/docs/current/sql-copy.html) 文档中定义的 `DELIMITER`、`HEADER` 和 `FORMAT` 选项。

```bash
psql -h DATABASE_URL -p 5432 -d postgres -U postgres \
  -c "\COPY movies FROM './movies.csv' WITH DELIMITER ',' CSV HEADER"
```

如果您收到 `FATAL: password authentication failed for user "postgres"` 错误，请在数据库设置中重置您的数据库密码并重试。

## 使用外键连接表格

表格可以通过外键"连接"在一起。

<Image
  alt="外键"
  zoomable
  src={{
    dark: '/docs/img/database/managing-tables/joining-tables.png',
    light: '/docs/img/database/managing-tables/joining-tables--light.png',
  }}
/>

这就是"关系型"命名的由来，因为数据通常会形成某种关系。

在上面的"电影"示例中，我们可能想为每部电影添加一个"类别"（例如，"动作片"或"纪录片"）。
让我们创建一个名为 `categories` 的新表格，并"链接"我们的 `movies` 表格。

```sql
create table categories (
  id bigint generated always as identity primary key,
  name text -- 类别名称
);

alter table movies
  add column category_id bigint references categories;
```

您还可以通过创建"连接"表格来创建"多对多"关系。
例如，如果您有以下情况：

- 您有一个 `movies` 列表。
- 一部电影可以有多位 `actors`。
- 一位 `actor` 可以在多部电影中表演。

<Tabs
  scrollable
  size="small"
  type="underlined"
  defaultActiveId="dashboard"
  queryGroup="database-method"
>
<TabPanel id="dashboard" label="仪表板">

<div className="video-container">
  <iframe
    src="https://www.youtube-nocookie.com/embed/TKwF3IGij5c"
    frameBorder="1"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowFullScreen
  ></iframe>
</div>

</TabPanel>
<TabPanel id="sql" label="SQL">

```sql
create table movies (
  id bigint generated by default as identity primary key,
  name text,
  description text
);

create table actors (
  id bigint generated by default as identity primary key,
  name text
);

create table performances (
  id bigint generated by default as identity primary key,
  movie_id bigint not null references movies,
  actor_id bigint not null references actors
);
```

</TabPanel>
</Tabs>

## 模式

表格属于 `schemas`（模式）。模式是组织表格的一种方式，通常出于安全原因。

<Image
  alt="模式和表格"
  zoomable
  src={{
    dark: '/docs/img/database/managing-tables/schemas.png',
    light: '/docs/img/database/managing-tables/schemas--light.png',
  }}
/>

如果在创建表格时不明确传递模式，Postgres 将假定您想在 `public` 模式中创建表格。

我们可以创建模式来组织表格。例如，我们可能想要一个隐藏在 API 之外的私有模式：

```sql
create schema private;
```

现在我们可以在 `private` 模式中创建表格：

```sql
create table private.salaries (
  id bigint generated by default as identity primary key,
  salary bigint not null,
  actor_id bigint not null references public.actors
);
```

## 视图

视图是查询的便捷快捷方式。创建视图不涉及新的表格或数据。运行时，会执行底层查询，将其结果返回给用户。

假设我们有以下来自大学数据库的表格：

**`students`**

{/* supa-mdx-lint-disable Rule003Spelling */}

| id  | name             | type          |
| --- | ---------------- | ------------- |
| 1   | Princess Leia    | undergraduate |
| 2   | Yoda             | graduate      |
| 3   | Anakin Skywalker | graduate      |

{/* supa-mdx-lint-enable Rule003Spelling */}

**`courses`**

| id  | title                    | code    |
| --- | ------------------------ | ------- |
| 1   | Introduction to Postgres | PG101   |
| 2   | Authentication Theories  | AUTH205 |
| 3   | Fundamentals of Supabase | SUP412  |

**`grades`**

| id  | student_id | course_id | result |
| --- | ---------- | --------- | ------ |
| 1   | 1          | 1         | B+     |
| 2   | 1          | 3         | A+     |
| 3   | 2          | 2         | A      |
| 4   | 3          | 1         | A-     |
| 5   | 3          | 2         | A      |
| 6   | 3          | 3         | B-     |

创建一个包含所有三个表格的视图将如下所示：

```sql
create view transcripts as
    select
        students.name,
        students.type,
        courses.title,
        courses.code,
        grades.result
    from grades
    left join students on grades.student_id = students.id
    left join courses on grades.course_id = courses.id;

grant all on table transcripts to authenticated;
```

完成后，我们现在可以通过以下方式访问底层查询：

```sql
select * from transcripts;
```

### 视图安全性

默认情况下，视图是使用其创建者的权限（"security definer"）访问的。如果有特权的角色创建视图，那么其他访问它的人将使用该角色的更高权限。要强制执行行级安全策略，请使用"security invoker"修饰符定义视图。

```sql
-- 将 security_definer 视图更改为 security_invoker
alter view <视图名称>
set (security_invoker = true);

-- 使用 security_invoker 修饰符创建视图
create view <视图名称> with(security_invoker=true) as (
  select * from <某个表格>
);
```

### 何时使用视图

视图提供了几个好处：

- 简洁性
- 一致性
- 逻辑组织
- 安全性

#### 简洁性

随着查询变得越来越复杂，反复调用它可能会很麻烦 - 尤其是当我们定期运行它时。在上面的例子中，我们可以不重复运行：

```sql
select
  students.name,
  students.type,
  courses.title,
  courses.code,
  grades.result
from
  grades
  left join students on grades.student_id = students.id
  left join courses on grades.course_id = courses.id;
```

而是运行：

```sql
select * from transcripts;
```

此外，视图的行为就像一个典型的表格。我们可以在表格 `JOIN` 中安全地使用它，甚至可以使用现有视图创建新视图。

#### 一致性

视图确保重复执行查询时出错的可能性降低。在上面的例子中，我们可能决定要排除课程 _Introduction to Postgres_。查询将变为：

```sql
select
  students.name,
  students.type,
  courses.title,
  courses.code,
  grades.result
from
  grades
  left join students on grades.student_id = students.id
  left join courses on grades.course_id = courses.id
where courses.code != 'PG101';
```

如果没有视图，我们需要进入每个依赖的查询来添加新规则。这会增加错误和不一致的可能性，并给开发人员带来很多工作。使用视图，我们可以只更改视图 **transcripts** 中的底层查询。更改将应用于使用该视图的所有应用程序。

#### 逻辑组织

使用视图，我们可以给查询一个名称。这对于使用同一数据库的团队非常有用。不必猜测查询的用途，一个命名良好的视图可以解释它。例如，通过查看视图名称 **transcripts**，我们可以推断底层查询可能涉及 **students**、**courses** 和 **grades** 表格。

#### 安全性

视图可以限制向用户呈现的数据量和类型。不是允许用户直接访问一组表格，而是提供给他们一个视图。我们可以通过从底层查询中排除敏感列来防止他们读取这些列。

### 物化视图

[物化视图](https://www.postgresql.org/docs/12/rules-materializedviews.html)是视图的一种形式，但它还将结果存储到磁盘上。在随后读取物化视图时，返回其结果所花费的时间将比传统视图快得多。这是因为物化视图的数据已经可用，而传统视图每次被调用时都会执行底层查询。

使用上面的例子，可以像这样创建物化视图：

```sql
create materialized view transcripts as
  select
    students.name,
    students.type,
    courses.title,
    courses.code,
    grades.result
  from
    grades
    left join students on grades.student_id = students.id
    left join courses on grades.course_id = courses.id;
```

从物化视图读取与从传统视图读取相同：

```sql
select * from transcripts;
```

### 刷新物化视图

不幸的是，这有一个权衡 - 物化视图中的数据并不总是最新的。我们需要定期刷新它，以防止数据变得过时。要这样做：

```sql
refresh materialized view transcripts;
```

至于多久刷新一次物化视图，这取决于您，并且可能因每个视图的用例而异。

### 物化视图与传统视图

当查询或视图的执行时间过长时，物化视图很有用。这很可能发生在涉及多个表格和数十亿行的视图或查询中。然而，在使用这种视图时，应该对数据过时有一定的容忍度。物化视图的一些用例是内部仪表板和分析。

创建物化视图并不是解决低效查询的方法。即使您正在实现物化视图，也应该始终寻求优化缓慢运行的查询。

## 资源

- [官方文档：创建表格](https://www.postgresql.org/docs/current/sql-createtable.html)
- [官方文档：创建视图](https://www.postgresql.org/docs/12/sql-createview.html)
- [Postgres 教程：创建表格](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-create-table/)
- [Postgres 教程：添加列](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-add-column/)
- [Postgres 教程：视图](https://www.postgresqltutorial.com/postgresql-views/)